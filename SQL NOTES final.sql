

-- -------------------------07 APR 2025 -- 3RD CLASS---------------------------------


CREATE DATABASE LIBRARYDB;
USE LIBRARYDB;
CREATE TABLE BOOKS(
BOOK_ID INT,
TITLE VARCHAR(100),
AUTHOR VARCHAR(100),
GENRE VARCHAR(100),
PUBLICATION INT,
PRICE DECIMAL(8,2)
);
DESC BOOKS;
INSERT INTO BOOKS(BOOK_ID,TITLE,AUTHOR,GENRE,PUBLICATION,PRICE)
VALUES
(1,"IT ENDS WITH US","COLLEEN","LOVE",2010,199),
(2,"IT STARTS WITH US","COLLEEN","LOVE",2015,199),
(3,"REVOLUTION 2022","CHETHAN BHAGAT","LOVE",2020,299),
(4,"ONE INDIAN GIRL","CHETHAN BHAGAT","LOVE",2022,299),
(5,"WHO WILL CRY WHEN U DIE","ROBIN SHARMA","PSYCH",2015,299),
(6,"I TOO HAD A LOVESTORY","RAVINDAR SINGH","TRAGEDY",2020,199);
DESC BOOKS;
SELECT * FROM BOOKS;

-- ARITHMETIC OPERATOR


UPDATE BOOKS SET PRICE=PRICE + 5.0;
SELECT * FROM BOOKS;

-- WHERE CLAUSE

UPDATE BOOKS SET PRICE=PRICE + 5.0 WHERE GENRE="TRAGEDY";
SELECT * FROM BOOKS;

UPDATE BOOKS SET PRICE=PRICE + 5.0 WHERE PUBLICATION>2020;
SELECT * FROM BOOKS;

UPDATE BOOKS SET PRICE=50 WHERE BOOK_ID % 2 <> 0;
SELECT * FROM BOOKS;

-- COMPARISON OPERATOR

SELECT * FROM BOOKS WHERE PUBLICATION=2022;
SELECT * FROM BOOKS WHERE GENRE !="LOVE";
SELECT * FROM BOOKS WHERE GENRE<>"LOVE";
SELECT * FROM BOOKS WHERE PUBLICATION<=2020;
SELECT * FROM BOOKS WHERE PUBLICATION>=2020;
SELECT * FROM BOOKS WHERE PUBLICATION<2020;
SELECT * FROM BOOKS WHERE PUBLICATION>2020;
SELECT * FROM BOOKS WHERE PUBLICATION BETWEEN 2015 AND 2020;
SELECT * FROM BOOKS WHERE PUBLICATION NOT BETWEEN 2015 AND 2020;
SELECT * FROM BOOKS WHERE GENRE IN("TRAGEDY","PSYCH");
SELECT * FROM BOOKS WHERE GENRE NOT IN("TRAGEDY","PSYCH");
SELECT * FROM BOOKS WHERE GENRE IS NULL;
SELECT * FROM BOOKS WHERE GENRE IS NOT NULL;

-- LOGICAL OPERATOR

SELECT * FROM BOOKS WHERE GENRE="TRAGEDY" OR GENRE="PSYCH";
SELECT * FROM BOOKS WHERE GENRE="TRAGEDY" AND GENRE="PSYCH";
SELECT * FROM BOOKS WHERE NOT GENRE="PSYCH";



-- ------------------------ 08 APRIL 2025 -- 4TH CLASS ----------------------------

CREATE DATABASE CONSTRAINTS;
USE CONSTRAINTS;
  
-- NOT NULL

CREATE TABLE STUDENT(
ID INTEGER,
FIRSTNAME TEXT NOT NULL,
LASTNAME TEXT NOT NULL
);
DESC STUDENT;

INSERT INTO STUDENT VALUES(1,"A","B");
SELECT * FROM STUDENT;
INSERT INTO STUDENT VALUES(2,NULL,NULL);   -- raise error as it can't allows null as values
INSERT INTO STUDENT VALUES(2,"B","B");
SELECT * FROM STUDENT;

-- DEFAULT

CREATE TABLE PERSON(
ID INT NOT NULL,
NAME VARCHAR(45) NOT NULL,
CITY VARCHAR(25) DEFAULT "HYD"
);
INSERT INTO PERSON VALUES(1,"ABC","NLG"),
(2,"XYZ",DEFAULT);
SELECT * FROM PERSON;

-- PRIMARY KEY

CREATE TABLE PERSONS(
ID INT NOT NULL PRIMARY KEY,
NAME VARCHAR(50),
LOCATION VARCHAR(15)
);
DESC PERSONS;
INSERT INTO PERSONS VALUES(1,"IUCDD","CDUJHE"),
(1,"HJCG","EDYUGDS");   --                         raises duplicate key error
INSERT INTO PERSONS VALUES(1,"IUCDD","CDUJHE"),
(2,"HJCG","EDYUGDS"); 
SELECT * FROM PERSONS;

-- TO DROP PRIMARY KEY

ALTER TABLE PERSONS
DROP PRIMARY KEY;
DESC PERSONS;

-- UNIQUE KEY
CREATE TABLE BRANDS(
ID INT,
BRANDNAME VARCHAR(40) UNIQUE,
SIZE VARCHAR(20)
);
DESC BRANDS;
INSERT INTO BRANDS VALUES(1,"ZUDIO","SMALL"),
(2,"ZUDIO","MEDIUM");  -- RAISES DUPLICATE ENTRY ERROR
INSERT INTO BRANDS VALUES(1,"ZUDIO","SMALL"),
(2,"AUDIO","MEDIUM");
SELECT * FROM BRANDS;


-- AUTO_INCREMENT
CREATE TABLE STUDENTS(
ID INT NOT NULL AUTO_INCREMENT,
NAME VARCHAR(40),
PRIMARY KEY(ID)
);
DESC STUDENTS;
INSERT INTO STUDENTS(NAME) VALUES("DFG"),
("DRFG"),("EEDRT"),("JHYG");
SELECT * FROM STUDENTS;

-- CHECK 
CREATE TABLE STUDENTS2(
ID INT NOT NULL,
NAME VARCHAR(50) NOT NULL,
AGE INT CHECK(AGE>=18)  -- ------------------RECHECKKKKKKKKKKKK
);
INSERT INTO STUDENTS2(ID,NAME,AGE) VALUES(1,"FGHJ",12);
SELECT * FROM STUDENTS2;

-- FOREIGN KEY
CREATE TABLE PERSON3(
ID INT NOT NULL PRIMARY KEY,
NAME VARCHAR(25),
AGE int
);
DESC PERSON3;
INSERT INTO PERSON3(ID,NAME,AGE) VALUES (1,"ESDF",23),
(2,"FTGY",25),
(3,"AWSED",27);
SELECT * FROM PERSON3;

CREATE TABLE ORDERS(
ORDER_ID INT NOT NULL PRIMARY KEY,
ORD_NUM INT NOT NULL,
ID INT,
FOREIGN KEY(ID) REFERENCES PERSON3(ID)
);
DESC ORDERS;
INSERT INTO ORDERS(ORDER_ID,ORD_NUM,ID) VALUES 
(001,5632,1),
(002,2356,2),
(003,6566,3);
SELECT * FROM ORDERS;




-- -------------------------------------- 09 APR 2025 -- 5TH CLASS --------------------------------------------------------------

-- COMPOSITE KEY --- SAME COURSE CAN BE APPLIED BY MULTIPLE STUDS , SINGLE STUD CAN APPLY MULTIPLE COURSES BUT EACH COURSE CAN B APPLIED ONLY ONCE 

CREATE TABLE STD_COURSE(
STD_ID INT,
COURSE_ID INT,
GRADE CHAR(1),
PRIMARY KEY ( STD_ID,COURSE_ID)       -- ------COMPOSITE KEY --
);
INSERT INTO STD_COURSE(STD_ID,COURSE_ID,GRADE) VALUES
(1,101,"A"),  -- UNIQUE 
(1,102,"A"),  -- SAME STD_ID BUT DIFF CRSE_ID
(2,101,"B"),  -- SAME COURSE_ID BUT DIFF STD-ID
(3,101,"A");  -- SAME COURSE_ID BUT DIFF STD-ID

SELECT * FROM STD_COURSE;
INSERT INTO STD_COURSE(STD_ID,COURSE_ID,GRADE) VALUES
(1,101,"B");       -- RAISE ERROR AS STD_ID , COURSE_ID COMBINATION IS REPEATED SAME

CREATE TABLE PRODUCTS(
PROD_ID INT PRIMARY KEY,
PROD_NAME VARCHAR(25) NOT NULL,
CATEGORY VARCHAR(25) NOT NULL,
PRICE DECIMAL(10,2) NOT NULL
);
INSERT INTO PRODUCTS(PROD_ID,PROD_NAME,CATEGORY,PRICE) VALUES
(1,"PC","ELECTRONICS",50000.00),
(2,"HEADPHONES","ELECTRONICS",2000.00),
(3,"COFFEE MAKER","APPLIANCES",5000.00),
(4,"SHOES","FASHION",2000.00),
(5,"BACKPACK","ACCESSORIES",3000.00);
SELECT * FROM PRODUCTS;


 -- ------------------------CLAUSES----------------------------------------------------
 
 
SELECT DISTINCT CATEGORY FROM PRODUCTS;
SELECT * FROM PRODUCTS ORDER BY PRICE DESC;
SELECT * FROM PRODUCTS LIMIT 2;
SELECT * FROM PRODUCTS LIMIT 2 OFFSET 2;
SELECT * FROM PRODUCTS WHERE PROD_NAME LIKE "S%";  -- STARTS WITH
SELECT * FROM PRODUCTS WHERE PROD_NAME LIKE "%R";  -- ENDS WITH
SELECT * FROM PRODUCTS WHERE PROD_NAME LIKE "%SHOES%"; 

-- ---------------------------------- CASE ----------------------------------------
-- SIMPLE CASE , SEARCHED CASE
CREATE DATABASE SCHOOLDB;
CREATE TABLE STUD(
ID INT PRIMARY KEY,
NAME VARCHAR(50),
MARKS int);
INSERT INTO STUD(ID,NAME,MARKS) VALUES
(11,"A",90),(21,"B",85),(13,"P",55),(14,"F",42);
-- SEARCHED CASE
SELECT ID,NAME,MARKS,
CASE 
WHEN MARKS>=90 THEN "A"
WHEN MARKS>=70 AND MARKS<90 THEN "B"
WHEN MARKS>=60 AND MARKS<70 THEN "C"
WHEN MARKS>=50 AND MARKS<60 THEN "D"
WHEN MARKS>=40 AND MARKS<50 THEN "E"
ELSE "F"
END AS GRADE
FROM STUD;

-- ORDER BY USING CASE
FROM STUD
ORDER BY
CASE
WHEN MARKS >= 92 THEN 4
WHEN MARKS >= 94 THEN 3
WHEN MARKS >= 96 THEN 2
WHEN MARKS >= 80 THEN 1
ELSE 5
END;

-- CASE IN UPDATE
ALTER TABLE STUD
ADD STATUS VARCHAR(10);
SELECT * FROM STUD;

UPDATE STUD
SET STATUS =
CASE 
WHEN MARKS >= 90 THEN "DISTINC"
WHEN MARKS >= 80 THEN "PASS"
ELSE "FAIL"
END;
SELECT * FROM STUD;



-- ------------------------------------------10 APR 2025 --- 6TH CLASS--------------------------------------------------------------

-- AGGREGATE FUNCTIONS---- COUNT , GROUPBY , MIN , MAX , SUM , HAVING

CREATE DATABASE CMPNYDB;
USE CMPNYDB;
CREATE TABLE AGG(
ID INT PRIMARY KEY,
NAME VARCHAR(30),
DEPT VARCHAR(30),
SALARY INT
);
DESC AGG;

INSERT INTO AGG(ID,NAME,DEPT,SALARY) VALUES
(1,"ABC","HR",50000),
(2,"DEF","FINANCE",45000),
(3,"GHI","IT",60000),
(4,"JKL","TECH SUPPORT",40000),
(5,"MNO","IT",55000),
(6,"PQR","HR",50000),
(7,"STU","FINANCE",40000);
SELECT * FROM AGG;

-- Q1) COUNT TOTAL NO. OF EMPLOYEES

SELECT COUNT(*) AS TOTAL_EMPL FROM AGG;

-- GROUPBY()

-- Q2) COUNT THE EMPLOYEES IN EACH DEPT
 SELECT DEPT,COUNT(*) AS EMP_COUNT 
 FROM AGG
 GROUP BY DEPT;
 
-- Q3) FIND THE MIN , MAX SALARY
-- MIN ,MAX
SELECT 
MIN(SALARY) AS MIN_SALARY,
MAX(SALARY) AS MAX_SALARY
FROM AGG;

-- Q4) FIND MIN,MAX SALARY DEPT WISE
SELECT DEPT,
MIN(SALARY) AS DEPT_MIN_SALARY,
MAX(SALARY) AS DEPT_MAX_SALARY
FROM AGG
GROUP BY DEPT;

-- Q5) FIND THE TOTAL,AVERAGE SALARY
SELECT 
SUM(SALARY) AS TOTAL_SAL,
AVG(SALARY) AS AVG_SAL
FROM AGG;

-- Q6) FIND THE TOTAL,AVERAGE SALARY DEPT WISE
SELECT DEPT,
SUM(SALARY) AS DEPT_TOTAL_SAL,
AVG(SALARY) AS DEPT_AVG_SAL
FROM AGG
GROUP BY DEPT;

-- HAVING
-- Q7) SHOW ONLY DEPT WHERE TOTAL SALARY IS ABOVE 100000
SELECT DEPT,
SUM(SALARY) AS TOTAL_SALARY 
FROM AGG
GROUP BY DEPT
HAVING SUM(SALARY)>100000;

-- ---------------------------------------------------------------- STRING FUNCTIONS -------------------------------

CREATE DATABASE STR;
USE STR;
CREATE TABLE STRFUNC(
ID INT PRIMARY KEY,
NAME VARCHAR(20),
BRAND VARCHAR(20),
PRICE INT
);
DESC STRFUNC;
INSERT INTO STRFUNC(ID,NAME,BRAND,PRICE) VALUES
(1,"LAPTOP","ASUS",50000),
(2,"MOBILE","ONE+",25000),
(3,"HEADPHONES","BOAT",1000),
(4,"POWERBANK","HP",2000),
(5,"SMARTWATCH","BOLT",5000);
SELECT * FROM STRFUNC;

-- Q1) FIND NO.OF PROD IN EACH BRAND WHERE AVG PRICE > 5000
SELECT BRAND,
AVG(PRICE) AS AVG_PRICE
FROM STRFUNC
GROUP BY BRAND
HAVING AVG(PRICE)>5000;

-- Q2)LIST THE BRAND THAT HAVE MORE THAN ONE PROD
SELECT BRAND,
COUNT(NAME) AS PROD_COUNT
FROM STRFUNC
GROUP BY BRAND
HAVING COUNT(NAME)>1;

-- ALIAS 
SELECT NAME AS "PROD_NAME",BRAND AS "BRAND_NAME"
FROM STRFUNC;
DESC STRFUNC;

-- CONCAT
SELECT CONCAT(NAME,BRAND) AS CONCATENATED
FROM STRFUNC;

-- CONCAT_WS
SELECT CONCAT_WS(",",NAME,BRAND) AS CONCATENATED
FROM STRFUNC;

-- LOWER
SELECT LOWER(NAME) AS LOW_COL
FROM STRFUNC;

-- UPPER
SELECT UPPER(NAME) AS UP_COL
FROM STRFUNC;

-- LENGTH
SELECT LENGTH(BRAND) AS LEN
FROM STRFUNC;

-- SUBSTRING
SELECT SUBSTRING(BRAND,2) AS SUB
FROM STRFUNC;

-- REVERSE
SELECT REVERSE(BRAND) AS RVRS
FROM STRFUNC; 

-- REPLACE
SELECT REPLACE(BRAND,"ASUS","VIVOBOOK") AS RPLC
FROM STRFUNC;

-- LEFT AND RIGHT
SELECT NAME,
LEFT(NAME,2) AS "LEFT",RIGHT(NAME,2) AS "RIGHT"
FROM STRFUNC;


-- --------------------------------------------------------11 APR 2025 -- 7th CLASS-------------------------------------------------------------------------------



-- DATE()
SELECT DATE("2024-01-08 15:30:15");

-- TIME
SELECT TIME("2024-01-08 15:30:15");

-- YEAR(),MONTH(),DAY()
SELECT YEAR("2024-01-08"),MONTH("2024-01-08"),DAY("2024-01-08");

-- NOW()
SELECT NOW();

-- CURDATE()
SELECT CURDATE();

-- CURTIME()
SELECT CURTIME();

-- CURRENT_TIMESTAMP()
SELECT CURRENT_TIMESTAMP();

-- DATE_FORMAT()
SELECT DATE_FORMAT("2024-01-08","%W,%M,%e,%Y");

-- DATEDIFF()
SELECT DATEDIFF("2024-01-08","2024-01-10");

-- DATE_ADD() , DATE_SUB()
SELECT DATE_ADD("2024-01-08" ,INTERVAL 5 DAY);
SELECT DATE_SUB('2024-01-08', INTERVAL 5 DAY);

-- EXTRACT()
SELECT EXTRACT(HOUR FROM "2024-01-08 15:10:03");

-- TIMESTAMPDIFF()
SELECT TIMESTAMPDIFF(SECOND,"2024-01-08 12:00:00","2024-01-08 12:00:45" );

-- TIMEDIFF()
SELECT TIMEDIFF("12:00:00","10:00:45" );

-- ADDTIME() SUBTIME()
SELECT ADDTIME("12:00:00","10:00:45" );
SELECT SUBTIME("12:00:00","10:00:45" );

-- FORMATTING DATES
SELECT DATE_FORMAT("2024-01-08 15:02:40","%W,%M,%e,%Y %H:%i:%s");
SELECT DATE_FORMAT("2024-01-08 15:02:40","%W,%b %d");

CREATE DATABASE PARTYPLANNER;
USE PARTYPLANNER;

CREATE TABLE CONTACTS(
ID INT PRIMARY KEY AUTO_INCREMENT,
NAME VARCHAR(50),
RELATION VARCHAR(50),
CITY VARCHAR(50),
LAST_CONTACTED DATE
);

INSERT INTO CONTACTS(NAME,RELATION,CITY,LAST_CONTACTED) VALUES
("SHIVA","BROTHER","DVK","2025-04-10"),
("HARSHITHA","FRND","HYD","2025-01-10"),
("KARTHIK","COUSIN","HYD","2025-03-10"),
("SHREYA","FRND","HYD","2025-01-10"),
("CHARAN","FRND","HYD","2025-02-14"),
("CHINTU","FRND","HYD","2024-12-10"),
("HEAMNTH","FRND","HYD","2025-02-21"),
("AJAY","COUSIN","DVK","2024-11-15"),
("KOUSHIK","COUSIN","HYD","2024-10-16"),
("SRINIPA","FRND","HYD","2025-02-10"),
("SHAREEN","FRND","BPT","2025-03-21"),
("SAI KIRAN","FRND","HYD","2025-01-10"),
("PRASHANTH","COUSIN","NLG","2025-03-21");
SELECT * FROM CONTACTS;

-- GET TOP TWO RELATIONS WITH RECENT CONTACT
SELECT RELATION,COUNT(*) AS GROUP_SIZE
FROM CONTACTS
WHERE LAST_CONTACTED >= DATE_SUB(CURDATE(), INTERVAL 2 MONTH)
GROUP BY RELATION
HAVING COUNT(*) >=2
ORDER BY GROUP_SIZE DESC
LIMIT 2 ;

-- GET THE CITIES WITH THE HIGHEST NO. OF CONTACTS MADE IN LAST 2 MNTHS SHOW TOP 2 CITIES
SELECT CITY,COUNT(*) AS CITY_SIZE
FROM CONTACTS
WHERE LAST_CONTACTED >= DATE_SUB(CURDATE(),INTERVAL 2 MONTH)
GROUP BY CITY
HAVING COUNT(*) >=2
ORDER BY CITY_SIZE DESC
LIMIT 2;



-- ------------------------------------------ 14 APR 2025-- 8TH CLASS-------------------------------------------------------------------------------------
-- ORDER OF EXECUTION

CREATE DATABASE COMPANY;
USE COMPANY;
CREATE TABLE DEPARTMENT(
DEPT_ID INT PRIMARY KEY,
DEPT_NAME VARCHAR(50),
LOCATION VARCHAR(50)
);

CREATE TABLE EMPLOYEE(
EMP_ID INT PRIMARY KEY ,
NAME VARCHAR(50),
SALARY DECIMAL(10,2),
DEPT_ID INT,
FOREIGN KEY(DEPT_ID) REFERENCES DEPARTMENT(DEPT_ID)
);

INSERT INTO DEPARTMENT(DEPT_ID,DEPT_NAME,LOCATION) VALUES
(1,"HR","HYD"),
(2,"IT","BNGLR"),
(3,"SALES","VZG");

INSERT INTO EMPLOYEE(EMP_ID,NAME,SALARY,DEPT_ID) VALUES
(101,"MANASA",55000,2),
(102,"SRAVANI",50000,1),
(103,"DEVI",40000,3),
(104,"HARSHITHA",35000,3),
(105,"SRINIPA",40000,2),
(106,"SHREYA",30000,1);

SELECT AVG(SALARY) FROM EMPLOYEE;

-- SCALAR QUERY

SELECT NAME FROM EMPLOYEE WHERE SALARY>(SELECT AVG(SALARY) FROM EMPLOYEE);

-- MULTIPLE ROW SUBQUERY

SELECT NAME FROM EMPLOYEE 
WHERE DEPT_ID IN(
SELECT DEPT_ID FROM DEPARTMENT WHERE LOCATION="HYD"
);


-- CORRELATED SUBQUERY

SELECT NAME
FROM EMPLOYEE 
WHERE SALARY> (
SELECT AVG(SALARY) FROM EMPLOYEE
WHERE DEPT_ID=EMPLOYEE.DEPT_ID
);


-- MULTIPLE SUBQUERY 
-- FIND THE EMPLOYEE NAMES WHO WORK IN DEPART LOCATED IN HYD OR BNGLR

SELECT NAME
FROM EMPLOYEE
WHERE DEPT_ID= (
SELECT DEPT_ID FROM DEPARTMENT
WHERE LOCATION IN ("HYD","BNGLR")
);                                                  -- RECHECKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK

-- CORRELATED
-- DISPLAY EPMLOYEE WHOSE SALARY IS LESS THAN MAXIMUM SALARY IN DEPARTMENT

-- --------------------------------------------------         ER DIAGRAM            ----------------------------------------------------------------------------------------
-- TO UNDERSTAND DATA
-- TO FIND RELATIONS
-- TO FIND DUPLICATES


-- ------------------------------------------------------ 15 APR 2025 9TH CLASS -----------------------------------------------------------------------------

-- JOINS ----- CROSS JOIN
            -- INNER JOIN
            -- FULL OUTER JOIN
            -- LEFT OUTER JOIN
            -- RIGHT OUTER JOIN
            -- SELF JOIN
            
-- SELECT * FROM TABLE1 CROSS JOIN TABLE2;
-- SELECT * FROM T1 INNER JOIN T2 ON T1.COLUMN=T2.COLUMN
-- SELECT * FROM T1 LEFT JOIN T2 ON T1.COLUMN=T2.COLUMN
-- SELECT * FROM T1 RIGHT JOIN T2 ON T1.COLUMN=T2.COLUMN

CREATE DATABASE JOINS;
USE JOINS;

CREATE TABLE EMPLY(
ID INT PRIMARY KEY,
E_NAME VARCHAR(50),
DEPT VARCHAR(50)
);

CREATE TABLE SALARY(
ID INT PRIMARY KEY,
EMP_ID INT,
SALARY DECIMAL(10,2),
FOREIGN KEY (EMP_ID) REFERENCES EMPLY(ID)
);

INSERT INTO EMPLY(ID,E_NAME,DEPT) VALUES
(1,"ABC","HR"),
(2,"DEF","IT"),
(3,"GHI","SALES"),
(4,"JKL","NON-IT");

INSERT INTO SALARY(ID,EMP_ID,SALARY) VALUES
(1,1,50000),
(2,3,55000),
(3,2,60000),
(4,4,55000);

-- CARTESIAN PRODUCT CROSS JOIN
SELECT * FROM EMPLY CROSS JOIN SALARY;

-- INNER JOIN 
SELECT * FROM EMPLY INNER JOIN SALARY ON EMPLY.ID=SALARY.ID; -- NO COMMON R GIVEN , TRY GIVING COMMON

-- OUTER JOIN
CREATE TABLE EMP(
ENAME VARCHAR(50),
DEPT_NO int
);

CREATE TABLE DEPT(
DNAME VARCHAR(25),
DEPT_NO INT
);

INSERT INTO EMP VALUES
("ABC",20),
("DEF",NULL),
("GHI",10),
("JKL",NULL);

INSERT INTO DEPT VALUES
("HR",10),
("SALES",30),
("IT",20),
("NON-IT",40);

SELECT EMP.ENAME, EMP.DEPT_NO, DEPT.DEPT_NO
FROM EMP 
LEFT JOIN 
DEPT ON EMP.DEPT_NO=DEPT.DEPT_NO;

SELECT * FROM EMP RIGHT JOIN DEPT ON EMP.DEPT_NO=DEPT.DEPT_NO;

-- SELECT * FROM EMP FULL OUTER JOIN DEPT ON EMP.DEPT_NO=DEPT.DEPT_NO;

-- SELF JOIN
CREATE TABLE EMP1(
EMP_ID INT PRIMARY KEY,
NAME VARCHAR(10),
M_ID int
);
INSERT INTO EMP1 VALUES
(1,"ABC",NULL),
(2,"RFR",1),
(3,"DRE",2),
(4,"THY",NULL),
(5,"FGH",3);

SELECT 
E1.NAME AS EMPLOYEE,
E2.NAME AS MANAGER
FROM 
EMP1 E1
JOIN 
EMP1 E2
ON 
E1.EMP_ID=E2.M_ID;


-- ----------------------------------------------------- 16  APR 2025 -- 10TH CLASS -----------------------------------------------------------------------


-- ------------------------------------------------------- SET OPERATIONS ----------------------------------------------------------------------------

CREATE DATABASE SET_OPERATIONS;
USE SET_OPERATIONS;

CREATE TABLE CUST(
ID INT PRIMARY KEY,
NAME VARCHAR(50),
CITY VARCHAR(50)
);

CREATE TABLE SUPPLIERS(
ID INT PRIMARY KEY,
NAME VARCHAR(50),
CITY VARCHAR(50)
);

INSERT INTO CUST VALUES
(1,"ABC","HYD"),
(2,"DEF","BNGLR"),
(3,"GHI","VZG"),
(4,"JKL","MUM");

INSERT INTO SUPPLIERS VALUE
(001,"PIOP","DVK"),
(002,"QWER","VZG"),
(003,"ASDF","SRYPT"),
(004,"YHGT","HYD");

-- UNION

SELECT CITY FROM CUST
UNION
SELECT CITY FROM SUPPLIERS;

-- UNION ALL

SELECT CITY FROM CUST
UNION ALL
SELECT CITY FROM SUPPLIERS;

-- INTERSECT
SELECT CITY FROM CUST 
INTERSECT
SELECT CITY FROM SUPPLIERS;

-- EXCEPT -----RETURNS RECORD FROM FIRST QUERY THAT ARE NOT IN SECOND
SELECT CITY FROM CUST 
WHERE CITY NOT IN (SELECT CITY FROM SUPPLIERS);

CREATE DATABASE UNIVERSITY;
USE UNIVERSITY;

CREATE TABLE STUDENTS(
STD_ID INT PRIMARY KEY,
NAME VARCHAR(100)
);

CREATE TABLE COURSES(
C_ID INT PRIMARY KEY,
C_NAME VARCHAR(50)
);

CREATE TABLE ENROLLMENT(
E_ID INT PRIMARY KEY,
STD_ID INT,
C_ID INT,
GRADE DECIMAL(10,2),
FOREIGN KEY (STD_ID) REFERENCES STUDENTS(STD_ID),
FOREIGN KEY (C_ID) REFERENCES COURSES(C_ID)
);

INSERT INTO STUDENTS VALUES
(1,"ABC"),
(2,"DEF"),
(3,"GHI");

INSERT INTO COURSES VALUES
(001,"DATA SCIENCE"),
(002,"DATA ANALYSIS"),
(003,"FULL STACK");

INSERT INTO ENROLLMENT VALUES
(100,2,001,98),
(101,1,003,95),
(103,2,002,80),
(104,2,003,75),
(105,1,002,65),
(106,3,001,74),
(102,3,002,90);

SELECT * FROM ENROLLMENT;

-- ---------------------------- DERIVED TABLE ---------------------------------------------------------------
-- SHOW ONLY STUDENTS WHOSE AVG GRADE ACROSS ALL COURSES IS GREATER THAN 45
SELECT NAME,AVG_GRADE FROM(
SELECT S.NAME ,AVG(E.GRADE) AS AVG_GRADE 
FROM STUDENTS S 
JOIN ENROLLMENT E ON S.STD_ID = E.STD_ID
GROUP BY S.STD_ID
) AS STD_AVG
WHERE AVG_GRADE > 45;


-- ---------------------------------------------- VIEW------------------------------------------------------------------

CREATE TABLE EMP(
ID INT PRIMARY KEY,
NAME VARCHAR(50),
SALARY DECIMAL(10,2)
);

INSERT INTO EMP VALUES
(1,"ABC",50000),
(2,"DEF",55000),
(3,"GHI",45000),
(4,"LKJ",52000);

CREATE VIEW HIGH_SALARIED AS 
SELECT NAME,SALARY
FROM emp
WHERE SALARY > 50000;
SELECT * FROM high_salaried;

CREATE VIEW LOW_SALARIED AS 
SELECT NAME,SALARY
FROM emp
WHERE SALARY < 55000;
SELECT * FROM low_salaried;

-- LEFT JOIN
SELECT * FROM EMPLY LEFT JOIN SALARY ON EMPLY.E_NAME=SALARY.SALARY ;

SELECT * FROM EMPLY LEFT JOIN SALARY ON EMPLY.ID=SALARY.SALARY ;

-- RIGHT JOIN 
SELECT * FROM EMPLY RIGHT JOIN SALARY ON EMPLY.ID=SALARY.SALARY ;



-- ---------------------------------------------------- 17 APR 2025 - 11TH CLASS -----------------------------------------------------------



-- ----------------------------------------------------- CTE --------> COMMON TABLE EXPRESSION


CREATE DATABASE CTE; 
USE CTE;


CREATE TABLE STUDENTS(
STD_ID INT PRIMARY KEY,
NAME VARCHAR(100)
);

CREATE TABLE COURSES(
C_ID INT PRIMARY KEY,
C_NAME VARCHAR(50)
);

CREATE TABLE ENROLLMENT(
E_ID INT PRIMARY KEY,
STD_ID INT,
C_ID INT,
GRADE DECIMAL(10,2),
FOREIGN KEY (STD_ID) REFERENCES STUDENTS(STD_ID),
FOREIGN KEY (C_ID) REFERENCES COURSES(C_ID)
);

INSERT INTO STUDENTS VALUES
(1,"ABC"),
(2,"DEF"),
(3,"GHI");

INSERT INTO COURSES VALUES
(001,"DATA SCIENCE"),
(002,"DATA ANALYSIS"),
(003,"FULL STACK");

INSERT INTO ENROLLMENT VALUES
(100,2,001,98),
(101,1,003,95),
(103,2,002,80),
(104,2,003,75),
(105,1,002,65),
(106,3,001,74),
(102,3,002,90);

-- USE CTE TO FIND STUDENTS WHOSE AVG GRADE ACROSS ALL COURSES IS GREATER THAN 85

WITH STD_AVG AS(
SELECT S.STD_ID,S.NAME,AVG(E.GRADE) AS AVG_GRADE
FROM STUDENTS S
JOIN ENROLLMENT E ON S.STD_ID=E.STD_ID
GROUP BY S.STD_ID
)
SELECT NAME,AVG_GRADE
FROM STD_AVGL
WHERE AVG_GRADE>85;

-- -------------------------------------------------- PROCEDURES ------------------------------------------------------------------------

CREATE TABLE IF NOT EXISTS EMP3 (
E_ID INT AUTO_INCREMENT PRIMARY KEY,
E_NAME VARCHAR(25),
DEPT_ID INT,
SALARY DECIMAL(10,2)
);

INSERT INTO EMP3(E_NAME,DEPT_ID,SALARY) VALUES 
("ABC",100,45000.00),
("DEF",101,54000.00),
("GHI",103,58000.00),
("JKL",104,35000.00),
("MNO",105,55000.00);

SELECT * FROM EMP3;


DELIMITER $$
CREATE PROCEDURE UPDATE_SLRY_BY_DEP(IN DEP_ID INT,IN NEW_SAL DECIMAL(10,2))
BEGIN 
UPDATE EMP3
SET SALARY=NEW_SAL
WHERE DEPT_ID=DEP_ID;
SELECT CONCAT("SALARIES UPDATED" ,DEP_ID) AS MESSAGE;
END $$
DELIMITER ;

CALL UPDATE_SLRY_BY_DEP(100,60000.00);
SELECT * FROM EMP3;




-- ----------------------------------------------------- 21 APR 2025 -- 12TH CLASS -----------------------------------------------------


-- ------------------------------------------------------------TRIGGERS -----------------------------------------------------------------

CREATE DATABASE TRIGGERDB;
USE TRIGGERDB;


CREATE TABLE EMP(
EMP_ID INT PRIMARY KEY,
NAME VARCHAR(30),
SALARY DECIMAL(10,2)
);

CREATE TABLE EMP_AUDIT_LOG(
LOG_ID INT AUTO_INCREMENT PRIMARY KEY,
EMP_ID INT,
OLD_SALARY DECIMAL(10,2),
NEW_SALARY DECIMAL(10,2),
CHANGEDATE DATETIME
);

INSERT INTO EMP VALUES
(1,"A",50000),
(2,"B",55000),
(3,"C",60000);



-- CREATING TRIGGER
DELIMITER $$
CREATE TRIGGER BEFORESALCHANGE
BEFORE UPDATE ON EMP 
FOR EACH ROW 
BEGIN
   IF NEW.SALARY < OLD.SALARY THEN
          SIGNAL SQLSTATE "55000"
          SET MESSAGE_TEXT ="SALARY CAN'T BE DECRESED";
   END IF;
END $$
DELIMITER ;


DELIMITER $$
CREATE TRIGGER AFTERSALCHANGE
AFTER UPDATE ON EMP 
FOR EACH ROW 
BEGIN
   INSERT INTO EMP_AUDIT_LOG(EMP_ID,OLD_SALARY,NEW_SALARY,CHANGEDATE) VALUES
   (OLD.EMP_ID,OLD.SALARY,NEW.SALARY,NOW());
END $$

UPDATE EMP 
SET SALARY = 70000
WHERE EMP_ID=2;



